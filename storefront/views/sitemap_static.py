"""
Static Sitemap Server - Production Grade

Serves pre-generated static sitemap files with proper HTTP headers.
Sitemaps are generated daily via: python manage.py generate_static_sitemaps

This approach:
✅ Zero database queries (prevents overload from Google crawl)
✅ Instant response (no rendering overhead)
✅ Proper HTTP caching (304 Not Modified)
✅ Scales to millions of URLs
✅ Works with CDNs and caching layers

FALLBACK: If static sitemap not found (new business, not yet generated),
falls back to dynamic generation from database with short-term cache.
"""

import os
import json
import logging
from django.http import HttpResponse, Http404
from django.views.decorators.http import condition
from django.views.decorators.cache import cache_page
from django.conf import settings
from django.template.loader import render_to_string
from ..client import get_supabase_client
from datetime import datetime

logger = logging.getLogger(__name__)


def format_date(date_str):
    """Format date to YYYY-MM-DD (Google sitemap standard)."""
    if not date_str:
        return datetime.now().strftime('%Y-%m-%d')
    try:
        if isinstance(date_str, str):
            return date_str[:10]
        return date_str.strftime('%Y-%m-%d')
    except:
        return datetime.now().strftime('%Y-%m-%d')


def get_sitemap_file(subdomain=None):
    """Get the path to the sitemap file."""
    sitemaps_dir = os.path.join(settings.BASE_DIR, 'storefront', 'static', 'sitemaps')
    
    if subdomain:
        # Business subdomain: {subdomain}_sitemap.xml
        filename = f"{subdomain}_sitemap.xml"
    else:
        # Main domain: sitemap_index.xml
        filename = "sitemap_index.xml"
    
    filepath = os.path.join(sitemaps_dir, filename)
    
    # Security: prevent directory traversal
    if not os.path.abspath(filepath).startswith(os.path.abspath(sitemaps_dir)):
        return None
    
    return filepath if os.path.exists(filepath) else None


def sitemap_last_modified(request, subdomain=None):
    """Return the last modified time of the sitemap file."""
    filepath = get_sitemap_file(subdomain)
    
    if not filepath:
        return None
    
    try:
        return os.path.getmtime(filepath)
    except (OSError, IOError):
        return None


@condition(last_modified_func=lambda r, s: sitemap_last_modified(r, s))
@cache_page(60 * 60)  # Cache for 1 hour (shorter for dynamic fallback)
def sitemap_products(request, subdomain=None):
    """
    Serve sitemap.xml for business subdomain.
    
    Call: GET /sitemap.xml (when on subdomain like alice.nexassearch.com)
    
    Two-tier approach:
    1. **STATIC** (preferred): Serve pre-generated XML file (24-hour cache, no DB queries)
    2. **DYNAMIC FALLBACK**: Generate on-the-fly for new businesses not yet in static cache
    
    Performance:
    - Static: No database queries, instant response
    - Fallback: Database query only for new businesses, 1-hour cache
    - Both: CDN-friendly with proper cache headers
    """
    subdomain = getattr(request, 'subdomain', None)
    
    if not subdomain:
        raise Http404("Sitemap not found. Use /static/sitemaps/sitemap_index.xml")
    
    # Try static first (production sitemap)
    filepath = get_sitemap_file(subdomain)
    
    if filepath:
        # Static sitemap found - serve it
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                content = f.read()
            
            return HttpResponse(
                content,
                content_type='application/xml',
                headers={
                    'Cache-Control': 'public, max-age=86400',  # 24 hours for static
                    'X-Sitemap-Generated': 'static',
                }
            )
        except IOError as e:
            logger.error(f'Error reading sitemap {filepath}: {str(e)}')
            # Fall through to dynamic generation
    
    # Static not found - generate dynamically for new businesses
    logger.info(f'Static sitemap not found for {subdomain}, falling back to dynamic generation')
    return generate_dynamic_sitemap(request, subdomain)


def generate_dynamic_sitemap(request, subdomain):
    """
    Dynamically generate sitemap for a business (used when static file doesn't exist).
    
    This is a fallback for newly signed-up businesses that haven't had sitemaps
    generated by the daily cron job yet.
    
    Cache: 1 hour (expires when static version is generated)
    """
    try:
        supabase = get_supabase_client()
        
        # Fetch business
        biz_response = supabase.table('business_profiles')\
            .select('*')\
            .eq('domain', subdomain)\
            .execute()
        
        if not biz_response.data:
            raise Http404(f"Business '{subdomain}' not found")
        
        business = biz_response.data[0]
        business_id = business.get('id')
        
        # Fetch products
        posts_response = supabase.table('posts')\
            .select('id,data,created_at,updated_at')\
            .eq('business_id', business_id)\
            .order('updated_at', desc=True)\
            .limit(50000)\
            .execute()
        
        urls = []
        
        # Add homepage
        urls.append({
            'loc': request.build_absolute_uri('/'),
            'lastmod': format_date(business.get('updated_at')),
            'changefreq': 'weekly',
            'priority': '1.0',
            'images': [],
        })
        
        # Add products
        for post in posts_response.data:
            post_data = post.get('data', {})
            if isinstance(post_data, str):
                post_data = json.loads(post_data)
            
            product_url = request.build_absolute_uri(f'/product/{post["id"]}/')
            
            # Extract images
            images = []
            images_list = post_data.get('images', [])
            if images_list and isinstance(images_list, list):
                for idx, img in enumerate(images_list[:3]):
                    img_url = img.get('url') if isinstance(img, dict) else str(img)
                    if img_url and img_url.startswith('http'):
                        images.append({
                            'loc': img_url,
                            'title': f"{post_data.get('productName', 'Product')} - Image {idx+1}",
                        })
            
            lastmod = post.get('updated_at') or post.get('created_at')
            
            urls.append({
                'loc': product_url,
                'lastmod': format_date(lastmod),
                'changefreq': 'weekly',
                'priority': '0.8',
                'images': images,
            })
        
        sitemap_xml = render_to_string('storefront/sitemap.xml', {'urls': urls})
        
        logger.info(f'Dynamically generated sitemap for {subdomain} with {len(urls)} URLs')
        
        return HttpResponse(
            sitemap_xml,
            content_type='application/xml',
            headers={
                'Cache-Control': 'public, max-age=3600',  # 1 hour for dynamic fallback
                'X-Sitemap-Generated': 'dynamic-fallback',
            }
        )
    
    except Http404:
        raise
    except Exception as e:
        logger.exception(f'Error generating dynamic sitemap for {subdomain}: {e}')
        raise Http404(f"Error generating sitemap for {subdomain}: {str(e)}")


@condition(last_modified_func=sitemap_last_modified)
@cache_page(60 * 60)  # Cache for 1 hour (shorter for fallback)
def sitemap_index(request):
    """
    Serve sitemap_index.xml from main domain.
    
    Call: GET /sitemap_index.xml (from main domain like nexassearch.com)
    
    Two-tier approach:
    1. **STATIC** (preferred): Pre-generated master index (24-hour cache, no DB queries)
    2. **DYNAMIC FALLBACK**: Generate on-the-fly if static not available
    
    Performance:
    - Static: No database queries, instant response
    - Fallback: Database query only if static missing, 1-hour cache
    """
    subdomain = getattr(request, 'subdomain', None)
    
    if subdomain:
        raise Http404("Use /sitemap.xml for business sitemaps")
    
    # Try static first
    filepath = get_sitemap_file(subdomain=None)
    
    if filepath:
        # Static sitemap index found
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                content = f.read()
            
            return HttpResponse(
                content,
                content_type='application/xml',
                headers={
                    'Cache-Control': 'public, max-age=86400',  # 24 hours for static
                    'X-Sitemap-Generated': 'static',
                }
            )
        except IOError as e:
            logger.error(f'Error reading sitemap index {filepath}: {str(e)}')
            # Fall through to dynamic generation
    
    # Static not found - generate dynamically
    logger.info('Static sitemap index not found, falling back to dynamic generation')
    return generate_dynamic_sitemap_index(request)


def generate_dynamic_sitemap_index(request):
    """
    Dynamically generate master sitemap index.
    
    This is a fallback if the static index hasn't been generated yet.
    """
    try:
        supabase = get_supabase_client()
        
        # Fetch all published businesses
        biz_response = supabase.table('business_profiles')\
            .select('domain,updated_at')\
            .eq('status', 'published')\
            .limit(50000)\
            .execute()
        
        sitemaps = []
        for biz in biz_response.data:
            if biz.get('domain'):
                sitemaps.append({
                    'loc': f"https://{biz['domain']}.nexassearch.com/sitemap.xml",
                    'lastmod': format_date(biz.get('updated_at')),
                })
        
        sitemap_index_xml = render_to_string('storefront/sitemap_index.xml', {
            'sitemaps': sitemaps,
        })
        
        logger.info(f'Dynamically generated sitemap index with {len(sitemaps)} business sitemaps')
        
        return HttpResponse(
            sitemap_index_xml,
            content_type='application/xml',
            headers={
                'Cache-Control': 'public, max-age=3600',  # 1 hour for dynamic fallback
                'X-Sitemap-Generated': 'dynamic-fallback',
            }
        )
    
    except Exception as e:
        logger.exception(f'Error generating dynamic sitemap index: {e}')
        raise Http404(f"Error generating sitemap index: {str(e)}")


def serve_sitemap_file(request, filename):
    """
    Serve any file from storefront/static/sitemaps/ when requested via
    /static/sitemaps/<filename>. This allows mapping static.nexassearch.com
    to the same Django host and serving sitemaps without touching the
    frontend repo or external storage.
    """
    # Basic filename validation: only allow xml and json files, no traversal
    if '..' in filename or '/' in filename or '\\' in filename:
        raise Http404('Invalid filename')

    allowed_ext = ('.xml', '.json')
    if not filename.lower().endswith(allowed_ext):
        raise Http404('Unsupported file type')

    sitemaps_dir = os.path.join(settings.BASE_DIR, 'storefront', 'static', 'sitemaps')
    filepath = os.path.join(sitemaps_dir, filename)

    if not os.path.exists(filepath):
        raise Http404('Sitemap not found')

    try:
        with open(filepath, 'rb') as f:
            data = f.read()

        content_type = 'application/xml' if filename.lower().endswith('.xml') else 'application/json'
        return HttpResponse(
            data,
            content_type=content_type,
            headers={
                'Cache-Control': 'public, max-age=86400',
                'X-Sitemap-Generated': 'static-file',
            }
        )

    except IOError as e:
        logger.error(f'Error reading sitemap file {filepath}: {str(e)}')
        raise Http404('Error reading sitemap file')
